print("IQR")
print(IQR)
# Now we will define the bounds of our data. If anything falls outside these bounds, we will remove them for being outliers.
lower_bound <- Q1 - 1.5 * IQR
print("lowerbound")
print(lower_bound)
upper_bound <- Q3 + 1.5 * IQR
print(upper_bound)
# Now, we will identify the outliers. We're going to omit the lower bound because we can't have negative gross square feet.
outliers <- which(DATA$logGROSS.SQUARE.FEET > upper_bound)
print("outliers")
outliers
#Using a different method to identify outliers
#Box_1 <- boxplot.stats(DATA$GROSS.SQUARE.FEET)
#Box_1
#Testing_Box <- boxplot.stats(DATA$GROSS.SQUARE.FEET)$out
#print("Outliers Boxplot stats")
#Testing_Box
#We've identified 24 outliers, now we need to remove them. Fixed_Data will refer to our data without these outliers in them.
Fixed_DATA <- DATA[-outliers, ]
# Calculate the quantiles and the IQR based on GSF.
DATA$logGROSS.SQUARE.FEET <- log(DATA$GROSS.SQUARE.FEET)
Q1 <- quantile(DATA$logGROSS.SQUARE.FEET, 0.01)
Q3 <- quantile(DATA$logGROSS.SQUARE.FEET, 0.99)
IQR <- Q3 - Q1
print("Q1")
print(Q1)
print("Q3")
print(Q3)
print("IQR")
print(IQR)
# Now we will define the bounds of our data. If anything falls outside these bounds, we will remove them for being outliers.
lower_bound <- Q1 - 1.5 * IQR
print("lowerbound")
print(lower_bound)
upper_bound <- Q3 + 1.5 * IQR
print(upper_bound)
# Now, we will identify the outliers. We're going to omit the lower bound because we can't have negative gross square feet.
outliers <- which(DATA$logGROSS.SQUARE.FEET > upper_bound)
print("outliers")
outliers
#Using a different method to identify outliers
#Box_1 <- boxplot.stats(DATA$GROSS.SQUARE.FEET)
#Box_1
#Testing_Box <- boxplot.stats(DATA$GROSS.SQUARE.FEET)$out
#print("Outliers Boxplot stats")
#Testing_Box
#We've identified 24 outliers, now we need to remove them. Fixed_Data will refer to our data without these outliers in them.
Fixed_DATA <- DATA[-outliers, ]
# Calculate the quantiles and the IQR based on GSF.
DATA$logGROSS.SQUARE.FEET <- log(DATA$GROSS.SQUARE.FEET)
Q1 <- quantile(DATA$logGROSS.SQUARE.FEET, 0.025)
Q3 <- quantile(DATA$logGROSS.SQUARE.FEET, 0.975)
IQR <- Q3 - Q1
print("Q1")
print(Q1)
print("Q3")
print(Q3)
print("IQR")
print(IQR)
# Now we will define the bounds of our data. If anything falls outside these bounds, we will remove them for being outliers.
lower_bound <- Q1 - 1.5 * IQR
print("lowerbound")
print(lower_bound)
upper_bound <- Q3 + 1.5 * IQR
print(upper_bound)
# Now, we will identify the outliers. We're going to omit the lower bound because we can't have negative gross square feet.
outliers <- which(DATA$logGROSS.SQUARE.FEET > upper_bound)
print("outliers")
outliers
#Using a different method to identify outliers
#Box_1 <- boxplot.stats(DATA$GROSS.SQUARE.FEET)
#Box_1
#Testing_Box <- boxplot.stats(DATA$GROSS.SQUARE.FEET)$out
#print("Outliers Boxplot stats")
#Testing_Box
#We've identified 24 outliers, now we need to remove them. Fixed_Data will refer to our data without these outliers in them.
Fixed_DATA <- DATA[-outliers, ]
# Calculate the quantiles and the IQR based on GSF.
DATA$logGROSS.SQUARE.FEET <- log(DATA$GROSS.SQUARE.FEET)
Q1 <- quantile(DATA$logGROSS.SQUARE.FEET, 0.25)
Q3 <- quantile(DATA$logGROSS.SQUARE.FEET, 0.75)
IQR <- Q3 - Q1
print("Q1")
print(Q1)
print("Q3")
print(Q3)
print("IQR")
print(IQR)
# Now we will define the bounds of our data. If anything falls outside these bounds, we will remove them for being outliers.
lower_bound <- Q1 - 1.5 * IQR
print("lowerbound")
print(lower_bound)
upper_bound <- Q3 + 1.5 * IQR
print(upper_bound)
# Now, we will identify the outliers. We're going to omit the lower bound because we can't have negative gross square feet.
outliers <- which(DATA$logGROSS.SQUARE.FEET > upper_bound)
print("outliers")
outliers
#Using a different method to identify outliers
#Box_1 <- boxplot.stats(DATA$GROSS.SQUARE.FEET)
#Box_1
#Testing_Box <- boxplot.stats(DATA$GROSS.SQUARE.FEET)$out
#print("Outliers Boxplot stats")
#Testing_Box
#We've identified 24 outliers, now we need to remove them. Fixed_Data will refer to our data without these outliers in them.
Fixed_DATA <- DATA[-outliers, ]
library(caret)
partition <- createDataPartition(DATA$GROSS.SQUARE.FEET, p = 0.7, list = FALSE)
data.train = DATA[partition, ]
data.test = DATA[-partition, ]
print("data.train")
mean(data.train$GROSS.SQUARE.FEET)
median(data.train$GROSS.SQUARE.FEET)
print("data.test")
mean(data.test$GROSS.SQUARE.FEET)
median(data.test$GROSS.SQUARE.FEET)
# Having removed the outliers from the data set has resulted in our means being very close! This is a good thing!
library(caret)
partition <- createDataPartition(DATA$GROSS.SQUARE.FEET, p = 0.7, list = FALSE)
data.train = DATA[partition, ]
data.test = DATA[-partition, ]
print("data.train")
mean(data.train$GROSS.SQUARE.FEET)
median(data.train$GROSS.SQUARE.FEET)
print("data.test")
mean(data.test$GROSS.SQUARE.FEET)
median(data.test$GROSS.SQUARE.FEET)
# Having removed the outliers from the data set has resulted in our means being very close! This is a good thing!
library(caret)
partition <- createDataPartition(DATA$GROSS.SQUARE.FEET, p = 0.7, list = FALSE)
data.train = DATA[partition, ]
data.test = DATA[-partition, ]
print("data.train")
mean(data.train$GROSS.SQUARE.FEET)
median(data.train$GROSS.SQUARE.FEET)
print("data.test")
mean(data.test$GROSS.SQUARE.FEET)
median(data.test$GROSS.SQUARE.FEET)
# Having removed the outliers from the data set has resulted in our means being very close! This is a good thing!
library(caret)
partition <- createDataPartition(DATA$GROSS.SQUARE.FEET, p = 0.7, list = FALSE)
data.train = DATA[partition, ]
data.test = DATA[-partition, ]
print("data.train")
mean(data.train$GROSS.SQUARE.FEET)
median(data.train$GROSS.SQUARE.FEET)
print("data.test")
mean(data.test$GROSS.SQUARE.FEET)
median(data.test$GROSS.SQUARE.FEET)
# Having removed the outliers from the data set has resulted in our means being very close! This is a good thing!
#This is creating a test and training data split based on a 70% 30% data split. It is also reporting the mean and median of our training and testing data.
library(caret)
partition <- createDataPartition(DATA$GROSS.SQUARE.FEET, p = 0.7, list = FALSE)
data.train = DATA[partition, ]
data.test = DATA[-partition, ]
print("data.train")
mean(data.train$GROSS.SQUARE.FEET)
median(data.train$GROSS.SQUARE.FEET)
print("data.test")
mean(data.test$GROSS.SQUARE.FEET)
median(data.test$GROSS.SQUARE.FEET)
library(caret)
partition <- createDataPartition(Fixed_DATA$GROSS.SQUARE.FEET, p = 0.7, list = FALSE)
data.train_F = DATA[partition, ]
data.test_F = DATA[-partition, ]
print("data.train_F")
mean(data.train_F$GROSS.SQUARE.FEET)
median(data.train_F$GROSS.SQUARE.FEET)
print("data.test_F")
mean(data.test_F$GROSS.SQUARE.FEET)
median(data.test_F$GROSS.SQUARE.FEET)
#This is creating a test and training data split based on a 70% 30% data split. It is also reporting the mean and median of our training and testing data.
library(caret)
partition <- createDataPartition(DATA$GROSS.SQUARE.FEET, p = 0.7, list = FALSE)
data.train = DATA[partition, ]
data.test = DATA[-partition, ]
print("data.train")
mean(data.train$GROSS.SQUARE.FEET)
median(data.train$GROSS.SQUARE.FEET)
print("data.test")
mean(data.test$GROSS.SQUARE.FEET)
median(data.test$GROSS.SQUARE.FEET)
library(caret)
partition <- createDataPartition(Fixed_DATA$GROSS.SQUARE.FEET, p = 0.7, list = FALSE)
data.train_F = DATA[partition, ]
data.test_F = DATA[-partition, ]
print("data.train_F")
mean(data.train_F$GROSS.SQUARE.FEET)
median(data.train_F$GROSS.SQUARE.FEET)
print("data.test_F")
mean(data.test_F$GROSS.SQUARE.FEET)
median(data.test_F$GROSS.SQUARE.FEET)
#This is creating a test and training data split based on a 70% 30% data split. It is also reporting the mean and median of our training and testing data.
library(caret)
partition <- createDataPartition(DATA$GROSS.SQUARE.FEET, p = 0.7, list = FALSE)
data.train = DATA[partition, ]
data.test = DATA[-partition, ]
print("data.train")
mean(data.train$GROSS.SQUARE.FEET)
median(data.train$GROSS.SQUARE.FEET)
print("data.test")
mean(data.test$GROSS.SQUARE.FEET)
median(data.test$GROSS.SQUARE.FEET)
library(caret)
partition2 <- createDataPartition(Fixed_DATA$GROSS.SQUARE.FEET, p = 0.7, list = FALSE)
data.train_F = DATA[partition2, ]
data.test_F = DATA[-partition2, ]
print("data.train_F")
mean(data.train_F$GROSS.SQUARE.FEET)
median(data.train_F$GROSS.SQUARE.FEET)
print("data.test_F")
mean(data.test_F$GROSS.SQUARE.FEET)
median(data.test_F$GROSS.SQUARE.FEET)
View(Fixed_DATA)
View(Fixed_DATA)
# Calculate the quantiles and the IQR based on GSF.
DATA$logGROSS.SQUARE.FEET <- log(DATA$GROSS.SQUARE.FEET)
Q1 <- quantile(DATA$logGROSS.SQUARE.FEET, 0.25)
Q3 <- quantile(DATA$logGROSS.SQUARE.FEET, 0.75)
IQR <- Q3 - Q1
print("Q1")
print(Q1)
print("Q3")
print(Q3)
print("IQR")
print(IQR)
# Now we will define the bounds of our data. If anything falls outside these bounds, we will remove them for being outliers.
lower_bound <- Q1 - 1.5 * IQR
print("lowerbound")
print(lower_bound)
upper_bound <- Q3 + 1.5 * IQR
print(upper_bound)
# Now, we will identify the outliers. We're going to omit the lower bound because we can't have negative gross square feet.
outliers <- which(DATA$logGROSS.SQUARE.FEET < lower_bound|DATA$logGROSS.SQUARE.FEET > upper_bound)
print("outliers")
outliers
#Using a different method to identify outliers
#Box_1 <- boxplot.stats(DATA$GROSS.SQUARE.FEET)
#Box_1
#Testing_Box <- boxplot.stats(DATA$GROSS.SQUARE.FEET)$out
#print("Outliers Boxplot stats")
#Testing_Box
#We've identified 24 outliers, now we need to remove them. Fixed_Data will refer to our data without these outliers in them.
Fixed_DATA <- DATA[-outliers, ]
#This is creating a test and training data split based on a 70% 30% data split. It is also reporting the mean and median of our training and testing data.
library(caret)
partition <- createDataPartition(DATA$GROSS.SQUARE.FEET, p = 0.7, list = FALSE)
data.train = DATA[partition, ]
data.test = DATA[-partition, ]
print("data.train")
mean(data.train$GROSS.SQUARE.FEET)
median(data.train$GROSS.SQUARE.FEET)
print("data.test")
mean(data.test$GROSS.SQUARE.FEET)
median(data.test$GROSS.SQUARE.FEET)
library(caret)
partition2 <- createDataPartition(Fixed_DATA$GROSS.SQUARE.FEET, p = 0.7, list = FALSE)
data.train_F = DATA[partition2, ]
data.test_F = DATA[-partition2, ]
print("data.train_F")
mean(data.train_F$GROSS.SQUARE.FEET)
median(data.train_F$GROSS.SQUARE.FEET)
print("data.test_F")
mean(data.test_F$GROSS.SQUARE.FEET)
median(data.test_F$GROSS.SQUARE.FEET)
#This is creating a test and training data split based on a 70% 30% data split. It is also reporting the mean and median of our training and testing data.
library(caret)
partition <- createDataPartition(DATA$GROSS.SQUARE.FEET, p = 0.7, list = FALSE)
data.train = DATA[partition, ]
data.test = DATA[-partition, ]
print("data.train")
mean(data.train$GROSS.SQUARE.FEET)
median(data.train$GROSS.SQUARE.FEET)
print("data.test")
mean(data.test$GROSS.SQUARE.FEET)
median(data.test$GROSS.SQUARE.FEET)
library(caret)
partition2 <- createDataPartition(Fixed_DATA$GROSS.SQUARE.FEET, p = 0.7, list = FALSE)
data.train_F = DATA[partition2, ]
data.test_F = DATA[-partition2, ]
print("data.train_F")
mean(data.train_F$GROSS.SQUARE.FEET)
median(data.train_F$GROSS.SQUARE.FEET)
print("data.test_F")
mean(data.test_F$GROSS.SQUARE.FEET)
median(data.test_F$GROSS.SQUARE.FEET)
#This is creating a test and training data split based on a 70% 30% data split. It is also reporting the mean and median of our training and testing data.
library(caret)
partition <- createDataPartition(DATA$GROSS.SQUARE.FEET, p = 0.7, list = FALSE)
data.train = DATA[partition, ]
data.test = DATA[-partition, ]
print("data.train")
mean(data.train$GROSS.SQUARE.FEET)
median(data.train$GROSS.SQUARE.FEET)
print("data.test")
mean(data.test$GROSS.SQUARE.FEET)
median(data.test$GROSS.SQUARE.FEET)
library(caret)
partition2 <- createDataPartition(Fixed_DATA$GROSS.SQUARE.FEET, p = 0.7, list = FALSE)
data.train_F = DATA[partition2, ]
data.test_F = DATA[-partition2, ]
print("data.train_F")
mean(data.train_F$GROSS.SQUARE.FEET)
median(data.train_F$GROSS.SQUARE.FEET)
print("data.test_F")
mean(data.test_F$GROSS.SQUARE.FEET)
median(data.test_F$GROSS.SQUARE.FEET)
#This is creating a test and training data split based on a 70% 30% data split. It is also reporting the mean and median of our training and testing data.
library(caret)
partition <- createDataPartition(DATA$GROSS.SQUARE.FEET, p = 0.7, list = FALSE)
data.train = DATA[partition, ]
data.test = DATA[-partition, ]
print("data.train")
mean(data.train$GROSS.SQUARE.FEET)
median(data.train$GROSS.SQUARE.FEET)
print("data.test")
mean(data.test$GROSS.SQUARE.FEET)
median(data.test$GROSS.SQUARE.FEET)
library(caret)
partition2 <- createDataPartition(Fixed_DATA$GROSS.SQUARE.FEET, p = 0.7, list = FALSE)
data.train_F = DATA[partition2, ]
data.test_F = DATA[-partition2, ]
print("data.train_F")
mean(data.train_F$GROSS.SQUARE.FEET)
median(data.train_F$GROSS.SQUARE.FEET)
print("data.test_F")
mean(data.test_F$GROSS.SQUARE.FEET)
median(data.test_F$GROSS.SQUARE.FEET)
#This is creating a test and training data split based on a 70% 30% data split. It is also reporting the mean and median of our training and testing data.
library(caret)
partition <- createDataPartition(DATA$GROSS.SQUARE.FEET, p = 0.7, list = FALSE)
data.train = DATA[partition, ]
data.test = DATA[-partition, ]
print("data.train")
mean(data.train$GROSS.SQUARE.FEET)
median(data.train$GROSS.SQUARE.FEET)
print("data.test")
mean(data.test$GROSS.SQUARE.FEET)
median(data.test$GROSS.SQUARE.FEET)
library(caret)
partition2 <- createDataPartition(Fixed_DATA$GROSS.SQUARE.FEET, p = 0.7, list = FALSE)
data.train_F = DATA[partition2, ]
data.test_F = DATA[-partition2, ]
print("data.train_F")
mean(data.train_F$GROSS.SQUARE.FEET)
median(data.train_F$GROSS.SQUARE.FEET)
print("data.test_F")
mean(data.test_F$GROSS.SQUARE.FEET)
median(data.test_F$GROSS.SQUARE.FEET)
mean(Fixed_DATA$GROSS.SQUARE.FEET)
#This is creating a test and training data split based on a 70% 30% data split. It is also reporting the mean and median of our training and testing data.
library(caret)
partition <- createDataPartition(DATA$GROSS.SQUARE.FEET, p = 0.7, list = FALSE)
data.train = DATA[partition, ]
data.test = DATA[-partition, ]
print("data.train")
mean(data.train$GROSS.SQUARE.FEET)
median(data.train$GROSS.SQUARE.FEET)
print("data.test")
mean(data.test$GROSS.SQUARE.FEET)
median(data.test$GROSS.SQUARE.FEET)
library(caret)
partition2 <- createDataPartition(Fixed_DATA$GROSS.SQUARE.FEET, p = 0.7, list = FALSE)
data.train_F = Fixed_DATA[partition2, ]
data.test_F = Fixed_DATA[-partition2, ]
print("data.train_F")
mean(data.train_F$GROSS.SQUARE.FEET)
median(data.train_F$GROSS.SQUARE.FEET)
print("data.test_F")
mean(data.test_F$GROSS.SQUARE.FEET)
median(data.test_F$GROSS.SQUARE.FEET)
#This is creating a test and training data split based on a 70% 30% data split. It is also reporting the mean and median of our training and testing data.
library(caret)
partition <- createDataPartition(DATA$GROSS.SQUARE.FEET, p = 0.7, list = FALSE)
data.train = DATA[partition, ]
data.test = DATA[-partition, ]
print("data.train")
mean(data.train$GROSS.SQUARE.FEET)
median(data.train$GROSS.SQUARE.FEET)
print("data.test")
mean(data.test$GROSS.SQUARE.FEET)
median(data.test$GROSS.SQUARE.FEET)
# We're doing this to create a partition just to see what it would look like using the fixed data.
library(caret)
partition2 <- createDataPartition(Fixed_DATA$GROSS.SQUARE.FEET, p = 0.7, list = FALSE)
data.train_F = Fixed_DATA[partition2, ]
data.test_F = Fixed_DATA[-partition2, ]
print("data.train_F")
mean(data.train_F$GROSS.SQUARE.FEET)
median(data.train_F$GROSS.SQUARE.FEET)
print("data.test_F")
mean(data.test_F$GROSS.SQUARE.FEET)
median(data.test_F$GROSS.SQUARE.FEET)
ggplot(Fixed_DATA, aes(x = logGROSS.SQUARE.FEET)) + geom_histogram()
model.full <- lm(logGROSS.SQUARE.FEET ~ BOROUGH.COMBINED + RESIDENTIAL.UNITS + COMMERCIAL.UNITS + YEAR.BUILT + COMBINED.TAX.CLASS.SALE)
model.full <- lm(
logGROSS.SQUARE.FEET ~ BOROUGH.COMBINED + RESIDENTIAL.UNITS + COMMERCIAL.UNITS + YEAR.BUILT + COMBINED.TAX.CLASS.SALE, data = Fixed_DATA
)
summary(model.full)
round(confint(model.full, level = 0.95), 2)
# This is the linear regression for the full model.
model.full <- lm(
logGROSS.SQUARE.FEET ~ BOROUGH.COMBINED + RESIDENTIAL.UNITS + COMMERCIAL.UNITS + YEAR.BUILT + COMBINED.TAX.CLASS.SALE, data = Fixed_DATA
)
summary(model.full)
# Calculate the quantiles and the IQR based on GSF.
DATA$logGROSS.SQUARE.FEET <- log(DATA$GROSS.SQUARE.FEET)
Q1 <- quantile(DATA$logGROSS.SQUARE.FEET, 0.25)
Q3 <- quantile(DATA$logGROSS.SQUARE.FEET, 0.75)
IQR <- Q3 - Q1
print("Q1")
print(Q1)
print("Q3")
print(Q3)
print("IQR")
print(IQR)
# Now we will define the bounds of our data. If anything falls outside these bounds, we will remove them for being outliers.
lower_bound <- Q1 - 1.5 * IQR
print("lowerbound")
print(lower_bound)
upper_bound <- Q3 + 1.5 * IQR
print(upper_bound)
# Now, we will identify the outliers. We're going to omit the lower bound because we can't have negative gross square feet.
outliers <- which(DATA$logGROSS.SQUARE.FEET < lower_bound|DATA$logGROSS.SQUARE.FEET > upper_bound)
print("outliers")
outliers
#Using a different method to identify outliers
#Box_1 <- boxplot.stats(DATA$GROSS.SQUARE.FEET)
#Box_1
#Testing_Box <- boxplot.stats(DATA$GROSS.SQUARE.FEET)$out
#print("Outliers Boxplot stats")
#Testing_Box
#We've identified 24 outliers, now we need to remove them. Fixed_Data will refer to our data without these outliers in them.
Fixed_DATA <- DATA[-outliers, ]
# This is the linear regression for the full model.
model.full <- lm(
logGROSS.SQUARE.FEET ~ BOROUGH.COMBINED + RESIDENTIAL.UNITS + COMMERCIAL.UNITS + YEAR.BUILT + SALE.PRICE + COMBINED.TAX.CLASS.SALE, data = Fixed_DATA
)
summary(model.full)
for (i in vars.categorical2){
# Use the table() function to calculate the frequencies for each factor
table <- as.data.frame(table(Fixed_DATA[, i]))
# Determine the level with the highest frequency
max <- which.max(table[, 2])
# Save the name of the level with the highest frequency
level.name <- as.character(table[max, 1])
# Set the baseline level to the most populous level
Fixed_DATA2[, i] <- relevel(Fixed_DATA[, i], ref = level.name)
}
for (i in vars.categorical2){
# Use the table() function to calculate the frequencies for each factor
table <- as.data.frame(table(Fixed_DATA[, i]))
# Determine the level with the highest frequency
max <- which.max(table[, 2])
# Save the name of the level with the highest frequency
level.name <- as.character(table[max, 1])
# Set the baseline level to the most populous level
Fixed_DATA[, i] <- relevel(Fixed_DATA[, i], ref = level.name)
}
View(Fixed_DATA)
View(Fixed_DATA)
for (i in vars.categorical2){
# Use the table() function to calculate the frequencies for each factor
table <- as.data.frame(table(Fixed_DATA[, i]))
# Determine the level with the highest frequency
max <- which.max(table[, 2])
# Save the name of the level with the highest frequency
level.name <- as.character(table[max, 1])
# Set the baseline level to the most populous level
Fixed_DATA[, i] <- relevel(Fixed_DATA[, i], ref = level.name)
}
print("Dimension of the Fixed Dataset")
dim(Fixed_DATA)
print("Categorical Summary")
summary(Fixed_DATA[, vars.categorical2])
# To make sure factors in the training set are releveled
data.train_F <- Fixed_DATA[partition, ]
model.full <- lm(
logGROSS.SQUARE.FEET ~ BOROUGH.COMBINED + RESIDENTIAL.UNITS + COMMERCIAL.UNITS + YEAR.BUILT + SALE.PRICE + COMBINED.TAX.CLASS.SALE, data = Fixed_DATA
)
summary(model.full)
for (i in vars.categorical2){
# Use the table() function to calculate the frequencies for each factor
table <- as.data.frame(table(Fixed_DATA[, i]))
# Determine the level with the highest frequency
max <- which.max(table[, 2])
# Save the name of the level with the highest frequency
level.name <- as.character(table[max, 1])
# Set the baseline level to the most populous level
Fixed_DATA[, i] <- relevel(Fixed_DATA[, i], ref = level.name)
}
print("Dimension of the Fixed Dataset")
dim(Fixed_DATA)
print("Categorical Summary")
summary(Fixed_DATA[, vars.categorical2])
#Notice that Manhattan's Borough is now too low. We will have to address this later as it under 5% of the observations.
# To make sure factors in the training set are releveled
data.train_F <- Fixed_DATA[partition, ]
model.full <- lm(
logGROSS.SQUARE.FEET ~ BOROUGH.COMBINED + RESIDENTIAL.UNITS + COMMERCIAL.UNITS + YEAR.BUILT + SALE.PRICE + COMBINED.TAX.CLASS.SALE, data = Fixed_DATA
)
summary(model.full)
#Now we're binarizing these variables.
library(caret)
binarizer <- dummyVars((~ BOROUGH.COMBINED + COMBINED.TAX.CLASS.SALE),
data = Fixed_DATA, fullRank = TRUE)
binarized_vars <- data.frame(predict(binarizer, newdata = Fixed_DATA))
head(binarized_vars)
outliers <- which(DATA$logGROSS.SQUARE.FEET < lower_bound|DATA$logGROSS.SQUARE.FEET > upper_bound)
print("outliers")
head(outliers)
